{"name": "test_static_tool_sees_class_members[jedi-trio.socket]", "status": "broken", "statusDetails": {"message": "ModuleNotFoundError: No module named 'jedi'", "trace": "tool = 'jedi', module_name = 'trio.socket', tmp_path = WindowsPath('C:/Users/ADMIN/AppData/Local/Temp/pytest-of-ADMIN/pytest-3/test_static_tool_sees_class_me4')\n\n    @slow\n    # see comment on test_static_tool_sees_all_symbols\n    @pytest.mark.redistributors_should_skip()\n    # Static analysis tools often have trouble with alpha releases, where Python's\n    # internals are in flux, grammar may not have settled down, etc.\n    @pytest.mark.skipif(\n        sys.version_info.releaselevel == \"alpha\",\n        reason=\"skip static introspection tools on Python dev/alpha releases\",\n    )\n    @pytest.mark.parametrize(\"module_name\", PUBLIC_MODULE_NAMES)\n    @pytest.mark.parametrize(\"tool\", [\"jedi\", \"mypy\"])\n    def test_static_tool_sees_class_members(\n        tool: str,\n        module_name: str,\n        tmp_path: Path,\n    ) -> None:\n        module = PUBLIC_MODULES[PUBLIC_MODULE_NAMES.index(module_name)]\n    \n        # ignore hidden, but not dunder, symbols\n        def no_hidden(symbols: Iterable[str]) -> set[str]:\n            return {\n                symbol\n                for symbol in symbols\n                if (not symbol.startswith(\"_\")) or symbol.startswith(\"__\")\n            }\n    \n        if tool == \"jedi\" and sys.implementation.name != \"cpython\":\n            pytest.skip(\"jedi does not support pypy\")\n    \n        if tool == \"mypy\":\n            cache = Path.cwd() / \".mypy_cache\"\n    \n            _ensure_mypy_cache_updated()\n    \n            trio_cache = next(cache.glob(\"*/trio\"))\n            modname = module_name\n            _, modname = (modname + \".\").split(\".\", 1)\n            modname = modname[:-1]\n            mod_cache = trio_cache / modname if modname else trio_cache\n            if mod_cache.is_dir():\n                mod_cache = mod_cache / \"__init__.data.json\"\n            else:\n                mod_cache = trio_cache / (modname + \".data.json\")\n    \n            assert mod_cache.exists()\n            assert mod_cache.is_file()\n            with mod_cache.open() as cache_file:\n                cache_json = json.loads(cache_file.read())\n    \n            # skip a bunch of file-system activity (probably can un-memoize?)\n            @functools.lru_cache\n            def lookup_symbol(symbol: str) -> dict[str, str]:\n                topname, *modname, name = symbol.split(\".\")\n                version = next(cache.glob(\"3.*/\"))\n                mod_cache = version / topname\n                if not mod_cache.is_dir():\n                    mod_cache = version / (topname + \".data.json\")\n    \n                if modname:\n                    for piece in modname[:-1]:\n                        mod_cache /= piece\n                    next_cache = mod_cache / modname[-1]\n                    if next_cache.is_dir():  # pragma: no coverage\n                        mod_cache = next_cache / \"__init__.data.json\"\n                    else:\n                        mod_cache = mod_cache / (modname[-1] + \".data.json\")\n                elif mod_cache.is_dir():\n                    mod_cache /= \"__init__.data.json\"\n                with mod_cache.open() as f:\n                    return json.loads(f.read())[\"names\"][name]  # type: ignore[no-any-return]\n    \n        errors: dict[str, object] = {}\n        for class_name, class_ in module.__dict__.items():\n            if not isinstance(class_, type):\n                continue\n            if module_name == \"trio.socket\" and class_name in dir(stdlib_socket):\n                continue\n    \n            # ignore class that does dirty tricks\n            if class_ is trio.testing.RaisesGroup:\n                continue\n    \n            # dir() and inspect.getmembers doesn't display properties from the metaclass\n            # also ignore some dunder methods that tend to differ but are of no consequence\n            ignore_names = set(dir(type(class_))) | {\n                \"__annotations__\",\n                \"__attrs_attrs__\",\n                \"__attrs_own_setattr__\",\n                \"__callable_proto_members_only__\",\n                \"__class_getitem__\",\n                \"__final__\",\n                \"__getstate__\",\n                \"__match_args__\",\n                \"__order__\",\n                \"__orig_bases__\",\n                \"__parameters__\",\n                \"__protocol_attrs__\",\n                \"__setstate__\",\n                \"__slots__\",\n                \"__weakref__\",\n                # ignore errors about dunders inherited from stdlib that tools might\n                # not see\n                \"__copy__\",\n                \"__deepcopy__\",\n            }\n    \n            if type(class_) is type:\n                # C extension classes don't have these dunders, but Python classes do\n                ignore_names.add(\"__firstlineno__\")\n                ignore_names.add(\"__static_attributes__\")\n    \n            # pypy seems to have some additional dunders that differ\n            if sys.implementation.name == \"pypy\":\n                ignore_names |= {\n                    \"__basicsize__\",\n                    \"__dictoffset__\",\n                    \"__itemsize__\",\n                    \"__sizeof__\",\n                    \"__weakrefoffset__\",\n                    \"__unicode__\",\n                }\n    \n            # inspect.getmembers sees `name` and `value` in Enums, otherwise\n            # it behaves the same way as `dir`\n            # runtime_names = no_underscores(dir(class_))\n            runtime_names = (\n                no_hidden(x[0] for x in inspect.getmembers(class_)) - ignore_names\n            )\n    \n            if tool == \"jedi\":\n                try:\n                    import jedi\n                except ImportError as error:\n>                   skip_if_optional_else_raise(error)\n\nLib\\site-packages\\trio\\_tests\\test_exports.py:377: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nLib\\site-packages\\trio\\_tests\\pytest_plugin.py:54: in skip_if_optional_else_raise\n    raise error\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ntool = 'jedi', module_name = 'trio.socket', tmp_path = WindowsPath('C:/Users/ADMIN/AppData/Local/Temp/pytest-of-ADMIN/pytest-3/test_static_tool_sees_class_me4')\n\n    @slow\n    # see comment on test_static_tool_sees_all_symbols\n    @pytest.mark.redistributors_should_skip()\n    # Static analysis tools often have trouble with alpha releases, where Python's\n    # internals are in flux, grammar may not have settled down, etc.\n    @pytest.mark.skipif(\n        sys.version_info.releaselevel == \"alpha\",\n        reason=\"skip static introspection tools on Python dev/alpha releases\",\n    )\n    @pytest.mark.parametrize(\"module_name\", PUBLIC_MODULE_NAMES)\n    @pytest.mark.parametrize(\"tool\", [\"jedi\", \"mypy\"])\n    def test_static_tool_sees_class_members(\n        tool: str,\n        module_name: str,\n        tmp_path: Path,\n    ) -> None:\n        module = PUBLIC_MODULES[PUBLIC_MODULE_NAMES.index(module_name)]\n    \n        # ignore hidden, but not dunder, symbols\n        def no_hidden(symbols: Iterable[str]) -> set[str]:\n            return {\n                symbol\n                for symbol in symbols\n                if (not symbol.startswith(\"_\")) or symbol.startswith(\"__\")\n            }\n    \n        if tool == \"jedi\" and sys.implementation.name != \"cpython\":\n            pytest.skip(\"jedi does not support pypy\")\n    \n        if tool == \"mypy\":\n            cache = Path.cwd() / \".mypy_cache\"\n    \n            _ensure_mypy_cache_updated()\n    \n            trio_cache = next(cache.glob(\"*/trio\"))\n            modname = module_name\n            _, modname = (modname + \".\").split(\".\", 1)\n            modname = modname[:-1]\n            mod_cache = trio_cache / modname if modname else trio_cache\n            if mod_cache.is_dir():\n                mod_cache = mod_cache / \"__init__.data.json\"\n            else:\n                mod_cache = trio_cache / (modname + \".data.json\")\n    \n            assert mod_cache.exists()\n            assert mod_cache.is_file()\n            with mod_cache.open() as cache_file:\n                cache_json = json.loads(cache_file.read())\n    \n            # skip a bunch of file-system activity (probably can un-memoize?)\n            @functools.lru_cache\n            def lookup_symbol(symbol: str) -> dict[str, str]:\n                topname, *modname, name = symbol.split(\".\")\n                version = next(cache.glob(\"3.*/\"))\n                mod_cache = version / topname\n                if not mod_cache.is_dir():\n                    mod_cache = version / (topname + \".data.json\")\n    \n                if modname:\n                    for piece in modname[:-1]:\n                        mod_cache /= piece\n                    next_cache = mod_cache / modname[-1]\n                    if next_cache.is_dir():  # pragma: no coverage\n                        mod_cache = next_cache / \"__init__.data.json\"\n                    else:\n                        mod_cache = mod_cache / (modname[-1] + \".data.json\")\n                elif mod_cache.is_dir():\n                    mod_cache /= \"__init__.data.json\"\n                with mod_cache.open() as f:\n                    return json.loads(f.read())[\"names\"][name]  # type: ignore[no-any-return]\n    \n        errors: dict[str, object] = {}\n        for class_name, class_ in module.__dict__.items():\n            if not isinstance(class_, type):\n                continue\n            if module_name == \"trio.socket\" and class_name in dir(stdlib_socket):\n                continue\n    \n            # ignore class that does dirty tricks\n            if class_ is trio.testing.RaisesGroup:\n                continue\n    \n            # dir() and inspect.getmembers doesn't display properties from the metaclass\n            # also ignore some dunder methods that tend to differ but are of no consequence\n            ignore_names = set(dir(type(class_))) | {\n                \"__annotations__\",\n                \"__attrs_attrs__\",\n                \"__attrs_own_setattr__\",\n                \"__callable_proto_members_only__\",\n                \"__class_getitem__\",\n                \"__final__\",\n                \"__getstate__\",\n                \"__match_args__\",\n                \"__order__\",\n                \"__orig_bases__\",\n                \"__parameters__\",\n                \"__protocol_attrs__\",\n                \"__setstate__\",\n                \"__slots__\",\n                \"__weakref__\",\n                # ignore errors about dunders inherited from stdlib that tools might\n                # not see\n                \"__copy__\",\n                \"__deepcopy__\",\n            }\n    \n            if type(class_) is type:\n                # C extension classes don't have these dunders, but Python classes do\n                ignore_names.add(\"__firstlineno__\")\n                ignore_names.add(\"__static_attributes__\")\n    \n            # pypy seems to have some additional dunders that differ\n            if sys.implementation.name == \"pypy\":\n                ignore_names |= {\n                    \"__basicsize__\",\n                    \"__dictoffset__\",\n                    \"__itemsize__\",\n                    \"__sizeof__\",\n                    \"__weakrefoffset__\",\n                    \"__unicode__\",\n                }\n    \n            # inspect.getmembers sees `name` and `value` in Enums, otherwise\n            # it behaves the same way as `dir`\n            # runtime_names = no_underscores(dir(class_))\n            runtime_names = (\n                no_hidden(x[0] for x in inspect.getmembers(class_)) - ignore_names\n            )\n    \n            if tool == \"jedi\":\n                try:\n>                   import jedi\nE                   ModuleNotFoundError: No module named 'jedi'\n\nLib\\site-packages\\trio\\_tests\\test_exports.py:375: ModuleNotFoundError"}, "parameters": [{"name": "tool", "value": "'jedi'"}, {"name": "module_name", "value": "'trio.socket'"}], "start": 1740044466615, "stop": 1740044466617, "uuid": "c1e59ac4-f7f0-4250-8a11-395a29e45bda", "historyId": "dad32d410f946e99645d969f09164c8f", "testCaseId": "0d3e650d9cff57d2891215f44cc7021c", "fullName": "Lib.site-packages.trio._tests.test_exports#test_static_tool_sees_class_members", "labels": [{"name": "tag", "value": "@pytest.mark.skipif(False, reason='skip static introspection tools on Python dev/alpha releases')"}, {"name": "tag", "value": "redistributors_should_skip"}, {"name": "parentSuite", "value": "Lib.site-packages.trio._tests"}, {"name": "suite", "value": "test_exports"}, {"name": "host", "value": "DESKTOP-5N0UDE1"}, {"name": "thread", "value": "15496-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "Lib.site-packages.trio._tests.test_exports"}]}